[
    {
        "id": "8c61a2a284d5b095",
        "type": "tab",
        "label": "Smart Bin Sensor Simulation",
        "disabled": false,
        "info": "This flow simulates a smart waste bin network with both edge and cloud processing paths to demonstrate efficiency differences."
    },
    {
        "id": "a3b5f0817e864e04",
        "type": "inject",
        "z": "8c61a2a284d5b095",
        "name": "Start Simulation",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 80,
        "wires": [
            [
                "49ad88c8838f7e57"
            ]
        ]
    },
    {
        "id": "49ad88c8838f7e57",
        "type": "function",
        "z": "8c61a2a284d5b095",
        "name": "Generate Bin Sensor Data",
        "func": "// Configuration for multiple bins\nconst numBins = 5;\nconst bins = [];\n\n// Create data for multiple bins\nfor (let i = 1; i <= numBins; i++) {\n    // Get persistent bin state from flow context or initialize\n    let binState = flow.get(`bin_${i}`) || {\n        fillLevel: Math.floor(Math.random() * 30), // Start with lower fill levels\n        fillRate: Math.random() * 3 + 1, // Different fill rates for different bins\n        temperature: Math.floor(Math.random() * 15) + 10, // 10-25°C\n        gasLevel: Math.floor(Math.random() * 200) + 100, // Initial gas levels\n        weight: Math.floor(Math.random() * 5) + 1, // Initial weight\n        humidity: Math.floor(Math.random() * 30) + 40, // Initial humidity\n        lastEmptied: Date.now() - (Math.random() * 86400000 * 7) // Random last emptied time\n    };\n    \n    // Realistically update bin state\n    binState.fillLevel += binState.fillRate * (Math.random() * 0.5 + 0.75); // Fill level increases over time\n    if (binState.fillLevel > 100) binState.fillLevel = 100; // Cap at 100%\n    \n    // Temperature varies slightly\n    binState.temperature += (Math.random() * 2 - 1);\n    \n    // Gas increases with fill level\n    const fillRatio = binState.fillLevel / 100;\n    binState.gasLevel = 100 + Math.floor(fillRatio * 400 + (Math.random() * 100 - 50));\n    \n    // Weight increases with fill level\n    binState.weight = 1 + Math.floor(fillRatio * 19 + (Math.random() * 3 - 1.5));\n    \n    // Humidity changes based on temperature and fill level\n    binState.humidity += (Math.random() * 4 - 2) + (fillRatio * 2);\n    binState.humidity = Math.max(20, Math.min(95, binState.humidity)); // Constrain\n    \n    // Save updated state\n    flow.set(`bin_${i}`, binState);\n    \n    // Create bin data object\n    bins.push({\n        binId: `bin_${i}`,\n        location: `Zone ${Math.ceil(i/2)}`,\n        timestamp: new Date().toISOString(),\n        sensors: {\n            fill_level: {\n                value: Math.round(binState.fillLevel),\n                unit: \"%\"\n            },\n            gas: {\n                value: Math.round(binState.gasLevel),\n                unit: \"ppm\"\n            },\n            temperature: {\n                value: Math.round(binState.temperature * 10) / 10, // One decimal place\n                unit: \"°C\"\n            },\n            humidity: {\n                value: Math.round(binState.humidity),\n                unit: \"%\"\n            },\n            weight: {\n                value: Math.round(binState.weight * 10) / 10, // One decimal place\n                unit: \"kg\"\n            }\n        },\n        lastEmptied: new Date(binState.lastEmptied).toISOString()\n    });\n}\n\n// Set up message with complete data\nmsg.payload = {\n    bins: bins,\n    totalBins: numBins,\n    timestamp: new Date().toISOString()\n};\n\n// Store metrics for this batch\nmsg.startTime = Date.now(); // For response time calculation\nmsg.dataSize = JSON.stringify(msg.payload).length; // Data size in bytes\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 80,
        "wires": [
            [
                "e437e07f8cd777b2",
                "1f58997871693c99"
            ]
        ]
    },
    {
        "id": "e437e07f8cd777b2",
        "type": "function",
        "z": "8c61a2a284d5b095",
        "name": "Edge Processing",
        "func": "// Process data on the edge\nconst edgeStart = Date.now();\n\n// Process bin data and generate alerts/actions\nconst processedBins = msg.payload.bins.map(bin => {\n    const fillLevel = bin.sensors.fill_level.value;\n    const gasLevel = bin.sensors.gas.value;\n    const temperature = bin.sensors.temperature.value;\n    \n    // Add processing results\n    return {\n        ...bin,\n        status: fillLevel > 80 ? \"NEEDS_EMPTYING\" : \n               fillLevel > 70 ? \"WARNING\" : \"OK\",\n        alerts: [\n            ...(fillLevel > 80 ? [{type: \"HIGH_FILL\", severity: \"HIGH\"}] : []),\n            ...(fillLevel > 70 ? [{type: \"APPROACHING_FULL\", severity: \"MEDIUM\"}] : []),\n            ...(gasLevel > 500 ? [{type: \"GAS_LEVEL_HIGH\", severity: \"HIGH\"}] : []),\n            ...(temperature > 30 ? [{type: \"HIGH_TEMPERATURE\", severity: \"MEDIUM\"}] : [])\n        ],\n        action: fillLevel > 80 ? \"SCHEDULE_COLLECTION\" : \"MONITOR\"\n    };\n});\n\n// Create summary\nconst binsNeedingEmptying = processedBins.filter(bin => bin.status === \"NEEDS_EMPTYING\").length;\nconst binsWarning = processedBins.filter(bin => bin.status === \"WARNING\").length;\n\n// Calculate processing time\nconst edgeEnd = Date.now();\nconst edgeProcessingTime = edgeEnd - edgeStart;\n\n// Response time (edge is typically very fast)\nconst responseTime = edgeEnd - msg.startTime;\n\n// Energy usage simulation (edge uses less power)\nconst energyUsage = 0.05; // kWh for edge processing\nconst co2 = energyUsage * 0.5; // kg CO2 (approximation)\n\n// Data transfer (edge sends less data)\nconst dataSent = Math.floor(msg.dataSize * 0.3); // Only send necessary data\n\n// Calculate costs\nconst processingCost = energyUsage * 0.15; // $0.15 per kWh\nconst dataCost = dataSent * 0.000001; // $0.000001 per byte\nconst totalCost = processingCost + dataCost;\n\nmsg.payload = {\n    ...msg.payload,\n    processedBins: processedBins,\n    summary: {\n        binsNeedingEmptying: binsNeedingEmptying,\n        binsWarning: binsWarning,\n        binsOk: msg.payload.bins.length - binsNeedingEmptying - binsWarning\n    },\n    metrics: {\n        path: \"edge\",\n        responseTime: responseTime,\n        processingTime: edgeProcessingTime,\n        energyUsage: energyUsage,\n        co2: co2,\n        dataSize: msg.dataSize,\n        dataSent: dataSent,\n        cost: totalCost\n    }\n};\n\n// Update global metrics\nlet edgeMetrics = flow.get(\"edgeMetrics\") || {\n    count: 0,\n    totalResponseTime: 0,\n    totalEnergy: 0,\n    totalCO2: 0,\n    totalCost: 0,\n    totalDataSent: 0\n};\n\nedgeMetrics.count++;\nedgeMetrics.totalResponseTime += responseTime;\nedgeMetrics.totalEnergy += energyUsage;\nedgeMetrics.totalCO2 += co2;\nedgeMetrics.totalCost += totalCost;\nedgeMetrics.totalDataSent += dataSent;\n\nflow.set(\"edgeMetrics\", edgeMetrics);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "x": 580,
        "y": 60,
        "wires": [
            [
                "9b6f24760abc7c85",
                "983bf41a42a04d2a"
            ]
        ]
    },
    {
        "id": "1f58997871693c99",
        "type": "delay",
        "z": "8c61a2a284d5b095",
        "name": "Simulate Network Latency",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 410,
        "y": 160,
        "wires": [
            [
                "d11e7c703651b051"
            ]
        ]
    },
    {
        "id": "d11e7c703651b051",
        "type": "function",
        "z": "8c61a2a284d5b095",
        "name": "Network Transfer Costs",
        "func": "// Simulate network transfer costs and bandwidth usage\n\n// Mobile data is expensive\nconst dataSize = msg.dataSize;\nconst transferCost = dataSize * 0.000005; // $0.000005 per byte\n\n// Also simulate packet loss or corruption sometimes\nconst reliability = Math.random();\nif (reliability < 0.05) {\n    // 5% chance of data corruption or loss\n    msg.networkIssue = \"Data corruption detected\";\n    \n    // Simulate partial data corruption\n    if (Math.random() < 0.5) {\n        const binIndex = Math.floor(Math.random() * msg.payload.bins.length);\n        if (msg.payload.bins[binIndex]) {\n            // Corrupt a random sensor reading\n            const sensors = Object.keys(msg.payload.bins[binIndex].sensors);\n            const sensorToCorrupt = sensors[Math.floor(Math.random() * sensors.length)];\n            msg.payload.bins[binIndex].sensors[sensorToCorrupt].value = null;\n            msg.networkIssue += ` - Bin ${binIndex+1} sensor data corrupted`;\n        }\n    }\n}\n\n// Add network metrics to the message\nmsg.networkMetrics = {\n    transferSize: dataSize,\n    transferCost: transferCost,\n    reliability: reliability * 100 // percentage\n};\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "x": 630,
        "y": 160,
        "wires": [
            [
                "06d1ebd6d21c6978"
            ]
        ]
    },
    {
        "id": "06d1ebd6d21c6978",
        "type": "function",
        "z": "8c61a2a284d5b095",
        "name": "Cloud Processing",
        "func": "// Process data in the cloud\nconst cloudStart = Date.now();\n\n// Process bin data (similar logic but we'll simulate more complex processing)\nconst processedBins = msg.payload.bins.map(bin => {\n    const fillLevel = bin.sensors.fill_level.value;\n    const gasLevel = bin.sensors.gas.value;\n    const temperature = bin.sensors.temperature.value;\n    \n    // Simulate more complex processing\n    let optimizedRoute = false;\n    let predictedFillDate = null;\n    \n    if (fillLevel > 50) {\n        // Calculate fill rate based on historical data\n        const currentDate = new Date();\n        const lastEmptied = new Date(bin.lastEmptied);\n        const daysSinceEmptied = (currentDate - lastEmptied) / (1000 * 60 * 60 * 24);\n        const estimatedFillRate = fillLevel / daysSinceEmptied; // % per day\n        \n        // Predict days until full\n        const daysUntilFull = (100 - fillLevel) / estimatedFillRate;\n        predictedFillDate = new Date();\n        predictedFillDate.setDate(predictedFillDate.getDate() + daysUntilFull);\n        \n        // Route optimization flag\n        optimizedRoute = fillLevel > 70;\n    }\n    \n    // Add processing results with more detail than edge processing\n    return {\n        ...bin,\n        status: fillLevel > 80 ? \"NEEDS_EMPTYING\" : \n               fillLevel > 70 ? \"WARNING\" : \"OK\",\n        alerts: [\n            ...(fillLevel > 80 ? [{type: \"HIGH_FILL\", severity: \"HIGH\"}] : []),\n            ...(fillLevel > 70 ? [{type: \"APPROACHING_FULL\", severity: \"MEDIUM\"}] : []),\n            ...(gasLevel > 500 ? [{type: \"GAS_LEVEL_HIGH\", severity: \"HIGH\"}] : []),\n            ...(temperature > 30 ? [{type: \"HIGH_TEMPERATURE\", severity: \"MEDIUM\"}] : [])\n        ],\n        analytics: {\n            predictedFillDate: predictedFillDate ? predictedFillDate.toISOString() : null,\n            optimizedRoute: optimizedRoute,\n            historical: {\n                avgFillRate: Math.random() * 5 + 5, // % per day (simulated)\n                collectionFrequency: Math.floor(Math.random() * 3) + 1 // times per week (simulated)\n            }\n        },\n        action: fillLevel > 80 ? \"SCHEDULE_COLLECTION\" : \"MONITOR\"\n    };\n});\n\n// Create summary\nconst binsNeedingEmptying = processedBins.filter(bin => bin.status === \"NEEDS_EMPTYING\").length;\nconst binsWarning = processedBins.filter(bin => bin.status === \"WARNING\").length;\n\n// Calculate processing metrics\nconst cloudEnd = Date.now();\nconst cloudProcessingTime = cloudEnd - cloudStart;\n\n// Response time (includes network delay)\nconst responseTime = cloudEnd - msg.startTime;\n\n// Energy usage simulation (cloud typically uses more power due to data center overhead)\nconst energyUsage = 0.2; // kWh for cloud processing\nconst co2 = energyUsage * 0.8; // kg CO2 (higher due to data center operations)\n\n// Calculate costs (cloud is typically more expensive)\nconst processingCost = energyUsage * 0.12; // $0.12 per kWh (cloud economies of scale)\nconst storageCost = msg.dataSize * 0.0000001 * 30; // $0.0000001 per byte per month\nconst networkCost = msg.networkMetrics ? msg.networkMetrics.transferCost : 0;\nconst totalCost = processingCost + storageCost + networkCost;\n\nmsg.payload = {\n    ...msg.payload,\n    processedBins: processedBins,\n    summary: {\n        binsNeedingEmptying: binsNeedingEmptying,\n        binsWarning: binsWarning,\n        binsOk: msg.payload.bins.length - binsNeedingEmptying - binsWarning\n    },\n    metrics: {\n        path: \"cloud\",\n        responseTime: responseTime,\n        processingTime: cloudProcessingTime,\n        energyUsage: energyUsage,\n        co2: co2,\n        dataSize: msg.dataSize,\n        networkIssue: msg.networkIssue || null,\n        cost: totalCost\n    }\n};\n\n// Update global metrics\nlet cloudMetrics = flow.get(\"cloudMetrics\") || {\n    count: 0,\n    totalResponseTime: 0,\n    totalEnergy: 0,\n    totalCO2: 0,\n    totalCost: 0\n};\n\ncloudMetrics.count++;\ncloudMetrics.totalResponseTime += responseTime;\ncloudMetrics.totalEnergy += energyUsage;\ncloudMetrics.totalCO2 += co2;\ncloudMetrics.totalCost += totalCost;\n\nflow.set(\"cloudMetrics\", cloudMetrics);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "x": 800,
        "y": 160,
        "wires": [
            [
                "9b6f24760abc7c85",
                "983bf41a42a04d2a"
            ]
        ]
    },
    {
        "id": "9b6f24760abc7c85",
        "type": "debug",
        "z": "8c61a2a284d5b095",
        "name": "Process Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1010,
        "y": 100,
        "wires": []
    },
    {
        "id": "983bf41a42a04d2a",
        "type": "function",
        "z": "8c61a2a284d5b095",
        "name": "Update Comparison Metrics",
        "func": "// Get stored metrics\nlet edgeMetrics = flow.get(\"edgeMetrics\") || {\n    count: 0,\n    totalResponseTime: 0,\n    totalEnergy: 0,\n    totalCO2: 0,\n    totalCost: 0,\n    totalDataSent: 0\n};\n\nlet cloudMetrics = flow.get(\"cloudMetrics\") || {\n    count: 0,\n    totalResponseTime: 0,\n    totalEnergy: 0,\n    totalCO2: 0,\n    totalCost: 0\n};\n\n// Skip if we don't have data for both yet\nif (edgeMetrics.count === 0 || cloudMetrics.count === 0) {\n    return null;\n}\n\n// Calculate averages\nconst comparison = {\n    responseTime: {\n        edge: edgeMetrics.totalResponseTime / edgeMetrics.count,\n        cloud: cloudMetrics.totalResponseTime / cloudMetrics.count,\n        improvement: ((cloudMetrics.totalResponseTime / cloudMetrics.count) / \n                    (edgeMetrics.totalResponseTime / edgeMetrics.count) - 1) * 100\n    },\n    energy: {\n        edge: edgeMetrics.totalEnergy / edgeMetrics.count,\n        cloud: cloudMetrics.totalEnergy / cloudMetrics.count,\n        savings: ((cloudMetrics.totalEnergy - edgeMetrics.totalEnergy) / \n                 cloudMetrics.totalEnergy) * 100\n    },\n    co2: {\n        edge: edgeMetrics.totalCO2 / edgeMetrics.count,\n        cloud: cloudMetrics.totalCO2 / cloudMetrics.count,\n        reduction: ((cloudMetrics.totalCO2 - edgeMetrics.totalCO2) / \n                   cloudMetrics.totalCO2) * 100\n    },\n    cost: {\n        edge: edgeMetrics.totalCost / edgeMetrics.count,\n        cloud: cloudMetrics.totalCost / cloudMetrics.count,\n        savings: ((cloudMetrics.totalCost - edgeMetrics.totalCost) / \n                 cloudMetrics.totalCost) * 100\n    },\n    totalSamples: Math.min(edgeMetrics.count, cloudMetrics.count)\n};\n\n// Only show significant figures\nconst formatNumber = (num) => {\n    if (typeof num !== 'number') return 'N/A';\n    if (Math.abs(num) < 0.01) return num.toExponential(2);\n    return Math.round(num * 100) / 100;\n};\n\nfor (const category in comparison) {\n    if (typeof comparison[category] === 'object') {\n        for (const key in comparison[category]) {\n            if (typeof comparison[category][key] === 'number') {\n                comparison[category][key] = formatNumber(comparison[category][key]);\n            }\n        }\n    }\n}\n\n// Store the comparison\nflow.set(\"comparisonMetrics\", comparison);\n\n// Create a message with the comparison\nmsg.payload = {\n    timestamp: new Date().toISOString(),\n    title: \"Edge vs Cloud Processing Comparison\",\n    metrics: comparison,\n    sustainabilityImpact: {\n        co2Reduction: comparison.co2.reduction + \"% CO2 reduction with edge processing\",\n        energySavings: comparison.energy.savings + \"% energy savings with edge processing\",\n        costSavings: comparison.cost.savings + \"% cost savings with edge processing\",\n        responseTimeImprovement: comparison.responseTime.improvement + \"% faster response with edge processing\"\n    },\n    hypothesis: \"Edge processing reduces delays, operational costs, and improves sustainability compared to cloud-only processing in waste management systems.\",\n    conclusion: comparison.responseTime.improvement > 0 && \n               comparison.cost.savings > 0 && \n               comparison.co2.reduction > 0 ? \n               \"The data supports the hypothesis.\" : \n               \"The hypothesis is not fully supported by the current data.\"\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1050,
        "y": 200,
        "wires": [
            [
                "f110328f2170b30b",
                "94a97052d87807c8"
            ]
        ]
    },
    {
        "id": "f110328f2170b30b",
        "type": "debug",
        "z": "8c61a2a284d5b095",
        "name": "Comparison Results",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1380,
        "y": 200,
        "wires": []
    },
    {
        "id": "ab39a65a49a6a084",
        "type": "ui_button",
        "z": "8c61a2a284d5b095",
        "name": "Reset Metrics",
        "group": "1d91ac8baa039d98",
        "order": 1,
        "width": 0,
        "height": 0,
        "passthru": false,
        "label": "Reset Simulation",
        "tooltip": "",
        "color": "",
        "bgcolor": "",
        "className": "",
        "icon": "",
        "payload": "",
        "payloadType": "str",
        "topic": "topic",
        "topicType": "msg",
        "x": 120,
        "y": 240,
        "wires": [
            [
                "fc67d749d920129e"
            ]
        ]
    },
    {
        "id": "fc67d749d920129e",
        "type": "function",
        "z": "8c61a2a284d5b095",
        "name": "Reset All Metrics",
        "func": "// Reset all metrics in flow context\nflow.set(\"edgeMetrics\", null);\nflow.set(\"cloudMetrics\", null);\nflow.set(\"comparisonMetrics\", null);\n\n// Reset bin states\nfor (let i = 1; i <= 10; i++) {\n    flow.set(`bin_${i}`, null);\n}\n\nreturn { payload: \"Metrics and bin states reset\" };",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "x": 280,
        "y": 240,
        "wires": [
            [
                "9b6f24760abc7c85"
            ]
        ]
    },
    {
        "id": "94a97052d87807c8",
        "type": "websocket out",
        "z": "8c61a2a284d5b095",
        "name": "",
        "server": "2edd959c62d7a2d2",
        "client": "",
        "x": 1440,
        "y": 40,
        "wires": []
    },
    {
        "id": "1d91ac8baa039d98",
        "type": "ui_group",
        "name": "Simulation Controls",
        "tab": "241c2e838d16e1b2",
        "order": 1,
        "disp": true,
        "width": "6",
        "collapse": false,
        "className": ""
    },
    {
        "id": "2edd959c62d7a2d2",
        "type": "websocket-listener",
        "path": "/smart-bins",
        "wholemsg": "false"
    },
    {
        "id": "241c2e838d16e1b2",
        "type": "ui_tab",
        "name": "Smart Bin Simulation",
        "icon": "dashboard",
        "disabled": false,
        "hidden": false
    }
]